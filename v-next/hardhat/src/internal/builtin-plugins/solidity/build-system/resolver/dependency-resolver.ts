import type { Remapping, Resolver } from "./types.js";
import type {
  ResolvedNpmPackage,
  ResolvedFile,
  FileContent,
  ProjectResolvedFile,
  NpmPackageResolvedFile,
} from "../../../../../types/solidity/resolved-file.js";

import path from "node:path";

import {
  HardhatError,
  assertHardhatInvariant,
} from "@nomicfoundation/hardhat-errors";
import { ensureError } from "@nomicfoundation/hardhat-utils/error";
import {
  FileNotFoundError,
  exists,
  getFileTrueCase,
  readJsonFile,
  readUtf8File,
} from "@nomicfoundation/hardhat-utils/fs";
import {
  findClosestPackageJson,
  findDependencyPackageJson,
} from "@nomicfoundation/hardhat-utils/package";
import { shortenPath } from "@nomicfoundation/hardhat-utils/path";
import { analyze } from "@nomicfoundation/solidity-analyzer";
import * as resolve from "resolve.exports";

import { ResolvedFileType } from "../../../../../types/solidity/resolved-file.js";
import { AsyncMutex } from "../../../../core/async-mutex.js";
import {
  NpmPackageResolvedFileImplementation,
  ProjectResolvedFileImplementation,
} from "../resolved-file.js";

import {
  applyValidRemapping,
  parseRemappingString,
  selectBestRemapping,
} from "./remappings.js";

// Things to note:
//  - This resolver assumes that the root of the project is the folder with the
//    closest package.json to the config file.
//  - Each file system file is resolved to a single ResolvedFile, with a unique
//    source name.
//  - Files within the project have their relative path as their source name.
//  - Files within npm packages have source names that start with `npm/` and
//    contain the package name and version. e.g. `npm/package@1.2.3/path.sol`.
//  - Files within npm packages that are part of a monorepo are resolved like
//    npm pacakges, but with the version `local`.
//  - This resolver fails if an import has a casing different from that of the
//    file system.
//  - We do not allow users to remap the imports present in files within npm
//    packages, by forbidding user remappings with context and starting with
//    `npm/`.
//  - We do allow users to remap imports of non-npm files, including remmapping
//    them into npm packages.
//  - Every import in an npm file is either relative or remapped by a remapping
//    generated by the resolver.
//  - A direct import (i.e. not relative) is considered to be local within the
//    the project/package if it is a bare file name (not in a directory), or if
//    the first directory exists in the project/package.
//  - The direct import "hardhat/console.sol" is a special case and it is never
//    considered to be local. And we only remap `hardhat/console.sol`.
//  - Local imports within the project may be remapped by user remappings, but
//    not by the resolver.
//  - Imports into npm packages are always remapped, if not by the user, by the
//    resolver.
//  - Direct local improts within npm package are always remapped by the
//    resolver.

/**
 * A user remapping, parsed, and with its npm package resolved, if any.
 */
interface ResolvedUserRemapping {
  rawFormat: string;
  context: string;
  prefix: string;
  target: string;
  targetNpmPackage?: ResolvedNpmPackage;
}

/**
 * A sentinel value that represents the root of the Hardhat project.
 */
const PROJECT_ROOT_SENTINEL: unique symbol = Symbol();

export class ResolverImplementation implements Resolver {
  readonly #projectRoot: string;
  readonly #userRemappings: ResolvedUserRemapping[];
  readonly #readFile: (absPath: string) => Promise<string>;

  /**
   * IMPORTANT: This mutex must be acquired before writing to any of the mutable
   * fields of this class. We do this by using the mutex in the public methods,
   * which don't call each other.
   */
  readonly #mutex = new AsyncMutex();

  /**
   * A map of all the npm dependencies used in the project, and their
   * dependencies.
   *
   * This is more complex than you may expect, as we have to handle:
   *
   *   - The Hardhat project itself, which is treated differently than npm
   *     packages, and is represented by the value `PROJECT_ROOT_SENTINEL`.
   *   - The case where a package is installed with a different name than the
   *     package's name in its `package.json`. We refer to the name with which
   *     the package is installed as the "installation name".
   *   - Imports from monorepo packages into the Hardhat project.
   */
  readonly #dependencyMaps: Map<
    ResolvedNpmPackage | typeof PROJECT_ROOT_SENTINEL,
    Map<
      string, // The installation-name of the package that is being imported
      ResolvedNpmPackage | typeof PROJECT_ROOT_SENTINEL // The package imported with that name
    >
  > = new Map();

  /**
   * A map of all the prefixes that an npm package needs to set as remappings
   * to avoid being affected by a user remapping.
   *
   * For example, if a package `foo` has an import `import "dep/File.sol";`,
   * and the user remaps `dep/=nope/`, it could break `foo`'s import.
   *
   * To avoid this situation we set all the prefixes that `foo` needs unaffected
   * by the user remapping, with a higher precedence than user remappings.
   */
  readonly #localPrefixesByPackage: Map<ResolvedNpmPackage, Set<string>> =
    new Map();

  /**
   * We use this map to ensure that we only resolve each file once.
   **/
  readonly #resolvedFileBySourceName: Map<string, ResolvedFile> = new Map();

  /**
   * Creates a new Resolver.
   *
   * @param projectRoot The absolute path to the Hardhat project root.
   * @param userRemappingStrings The remappings provided by the user.
   */
  public static async create(
    projectRoot: string,
    userRemappingStrings: string[],
    readFile: (absPath: string) => Promise<string> = readUtf8File,
  ): Promise<Resolver> {
    const userRemappings = await Promise.all(
      userRemappingStrings.map((remappingString) =>
        validateAndResolveUserRemapping(projectRoot, remappingString),
      ),
    );

    return new ResolverImplementation(projectRoot, userRemappings, readFile);
  }

  private constructor(
    projectRoot: string,
    userRemappings: ResolvedUserRemapping[],
    readFile: (absPath: string) => Promise<string>,
  ) {
    this.#projectRoot = projectRoot;
    this.#userRemappings = userRemappings;
    this.#dependencyMaps.set(PROJECT_ROOT_SENTINEL, new Map());
    this.#readFile = readFile;
  }

  public async resolveProjectFile(
    absoluteFilePath: string,
  ): Promise<ProjectResolvedFile> {
    return this.#mutex.exclusiveRun(async () => {
      if (!absoluteFilePath.startsWith(this.#projectRoot)) {
        throw new HardhatError(
          HardhatError.ERRORS.CORE.SOLIDITY.RESOLVING_INCORRECT_FILE_AS_PROJECT_FILE,
          {
            file: shortenPath(absoluteFilePath),
          },
        );
      }

      const relativeFilePath = path.relative(
        this.#projectRoot,
        absoluteFilePath,
      );

      // We first check if the file has already been resolved.
      //
      // Note that it may have received the right path, but with the wrong
      // casing. We don't care at this point, as it would just mean a cache
      // miss, and we proceed to get the right casing in that case.
      //
      // However, as most of the time these absolute paths are read from the file
      // system, they'd have the right casing in general.
      //
      // If we need to fetch the right casing, we'd have to recheck the cache,
      // to avoid re-resolving the file.
      let sourceName = fsPathToSourceNamePath(relativeFilePath);
      const existing = this.#resolvedFileBySourceName.get(sourceName);

      if (existing !== undefined) {
        /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a ProjectResolvedFile */
        return existing as ProjectResolvedFile;
      }

      let trueCaseFsPath: string;
      try {
        trueCaseFsPath = await getFileTrueCase(
          this.#projectRoot,
          relativeFilePath,
        );
      } catch (error) {
        ensureError(error, FileNotFoundError);

        throw new HardhatError(
          HardhatError.ERRORS.CORE.SOLIDITY.RESOLVING_NONEXISTENT_PROJECT_FILE,
          { file: shortenPath(absoluteFilePath) },
          error,
        );
      }

      // Now that we have the correct casing, we "fix" the source name.
      sourceName = fsPathToSourceNamePath(trueCaseFsPath);

      // Maybe it was already resolved, so we need to check with the right
      // casing
      const resolvedWithTheRightCasing =
        this.#resolvedFileBySourceName.get(sourceName);
      if (resolvedWithTheRightCasing !== undefined) {
        /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      -- If it was, it's a ProjectResolvedFile */
        return resolvedWithTheRightCasing as ProjectResolvedFile;
      }

      const fsPathWithTheRightCasing = path.join(
        this.#projectRoot,
        trueCaseFsPath,
      );

      const resolvedFile: ProjectResolvedFile =
        new ProjectResolvedFileImplementation({
          sourceName,
          fsPath: fsPathWithTheRightCasing,
          content: await this.#readFileContent(fsPathWithTheRightCasing),
        });

      this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

      return resolvedFile;
    });
  }

  public async resolveNpmDependencyFileAsRoot(
    npmModule: string,
  ): Promise<NpmPackageResolvedFile> {
    return this.#mutex.exclusiveRun(async () => {
      const parsedNpmModule = this.#parseNpmDirectImport(npmModule);

      if (parsedNpmModule === undefined) {
        throw new HardhatError(
          HardhatError.ERRORS.CORE.SOLIDITY.RESOLVE_NPM_FILE_WITH_INVALID_FORMAT,
          { module: npmModule },
        );
      }

      if (await this.#isDirectImportLocal(this.#projectRoot, npmModule)) {
        const directory =
          this.#getDirectImportLocalDesambiguationPrefix(npmModule);

        throw new HardhatError(
          HardhatError.ERRORS.CORE.SOLIDITY.RESOLVE_NPM_FILE_CLASHES_WITH_LOCAL_FILES,
          {
            module: npmModule,
            directory,
          },
        );
      }

      const modulePackageName = parsedNpmModule.package;

      const npmPackage = await this.#resolveNpmPackage({
        from: PROJECT_ROOT_SENTINEL,
        packageName: modulePackageName,
      });

      assertHardhatInvariant(
        npmPackage !== PROJECT_ROOT_SENTINEL,
        "Resolving a local file as if it were an npm module",
      );

      const subpath = parsedNpmModule.subpath;
      const resolvedSubpath = resolveSubpath(npmPackage, subpath);

      const relativeFsPath = sourceNamePathToFsPath(resolvedSubpath);
      let trueCaseFsPath: string;
      try {
        trueCaseFsPath = await getFileTrueCase(
          npmPackage.rootFsPath,
          relativeFsPath,
        );
      } catch (error) {
        ensureError(error, FileNotFoundError);

        throw new HardhatError(
          HardhatError.ERRORS.CORE.SOLIDITY.RESOLVE_NON_EXISTENT_NPM_ROOT,
          { module: npmModule },
          error,
        );
      }

      if (relativeFsPath !== trueCaseFsPath) {
        throw new HardhatError(
          HardhatError.ERRORS.CORE.SOLIDITY.RESOLVE_WRONG_CASING_NPM_ROOT,
          { module: npmModule },
        );
      }

      const sourceName = sourceNamePathJoin(
        npmPackageToRootSourceName(npmPackage.name, npmPackage.version),
        // We use the subpath (pre-resolution) to create source names
        subpath,
      );

      const resolved = this.#resolvedFileBySourceName.get(sourceName);

      if (resolved !== undefined) {
        /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      -- If it was, it's a ProjectResolvedFile */
        return resolved as NpmPackageResolvedFile;
      }

      const fsPath = path.join(npmPackage.rootFsPath, trueCaseFsPath);

      const resolvedFile: NpmPackageResolvedFile =
        new NpmPackageResolvedFileImplementation({
          sourceName,
          fsPath,
          content: await this.#readFileContent(fsPath),
          package: npmPackage,
        });

      this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

      return resolvedFile;
    });
  }

  public async resolveImport(
    from: ResolvedFile,
    importPath: string,
  ): Promise<ResolvedFile> {
    return this.#mutex.exclusiveRun(async () => {
      let directImport = importPath;

      if (path.sep !== "/" && importPath.includes(path.sep)) {
        throw new HardhatError(
          HardhatError.ERRORS.CORE.SOLIDITY.IMPORT_PATH_WITH_WINDOWS_SEPARATOR,
          {
            importPath,
            from: shortenPath(from.fsPath),
          },
        );
      }

      if (importPath.startsWith("./") || importPath.startsWith("../")) {
        directImport = sourceNamePathJoin(
          path.dirname(from.sourceName),
          importPath,
        );

        if (from.type === ResolvedFileType.NPM_PACKAGE_FILE) {
          if (!directImport.startsWith(from.package.rootSourceName)) {
            throw new HardhatError(
              HardhatError.ERRORS.CORE.SOLIDITY.ILLEGAL_PACKAGE_IMPORT,
              {
                importPath,
                from: shortenPath(from.fsPath),
              },
            );
          }
        } else {
          if (directImport.startsWith("../")) {
            throw new HardhatError(
              HardhatError.ERRORS.CORE.SOLIDITY.ILEGALL_PROJECT_IMPORT,
              {
                importPath,
                from: shortenPath(from.fsPath),
              },
            );
          }
        }
      }

      switch (from.type) {
        case ResolvedFileType.PROJECT_FILE:
          return this.#resolveImportFromProjectFile({
            from,
            importPath,
            directImport,
          });

        case ResolvedFileType.NPM_PACKAGE_FILE:
          return this.#resolveImportFromNpmPackageFile({
            from,
            importPath,
            directImport,
          });
      }
    });
  }

  public getRemappings(): Remapping[] {
    const userRemappings = this.#userRemappings.map((remapping) => ({
      context: remapping.context,
      prefix: remapping.prefix,
      target: remapping.target,
    }));

    const remappings: Remapping[] = [];

    for (const [
      thePackage,
      dependenciesMap,
    ] of this.#dependencyMaps.entries()) {
      let context: string;

      if (thePackage === PROJECT_ROOT_SENTINEL) {
        context = "";
      } else {
        context = thePackage.rootSourceName;
      }

      for (const [importedPackage, dependency] of dependenciesMap.entries()) {
        // As `hardhat/console.sol` is always resolved through npm, even if the
        // `hardhat/` folder exists in the root of the package/project, we
        // only remap that file.
        //
        // We should revisit this if we exported more solidity files in the
        // hardhat package in the future.
        //
        // Also note that we are using the importedPackageName here, and not
        // the dependency's name, and that's because we always resolve 'hardhat'
        // as the hh package itself. If someone installs another package as
        // "hardhat", it may break.
        if (
          dependency !== PROJECT_ROOT_SENTINEL &&
          importedPackage === "hardhat"
        ) {
          const prefix = importedPackage + "/console.sol";
          const target = dependency.rootSourceName + "console.sol";

          remappings.push({ context, prefix, target });
        } else {
          const prefix = importedPackage + "/";

          const target =
            dependency === PROJECT_ROOT_SENTINEL
              ? ""
              : dependency.rootSourceName;

          // If a dependency is being remapped by the user using the same
          // prefix, we don't want to override it, as it can cause problems
          // when a file from that dependency is also treated as a root.
          //
          // For example, if the user sets this remapping
          // "forge-std/=npm/forge-std@1.9.4/src/" and for some reason also
          // compiles "forge-std/src/Test.sol" as a root.
          //
          // Without this check, we would have two remappings in the solc input:
          //    "forge-std/=npm/forge-std@1.9.4/src/"
          //    "forge-std/=npm/forge-std@1.9.4/"
          // and the latter would win, leading to a compilation error.
          if (thePackage === PROJECT_ROOT_SENTINEL) {
            if (this.#userRemappings.some((r) => r.prefix === prefix)) {
              continue;
            }
          }

          remappings.push({ context, prefix, target });
        }
      }
    }

    // TODO: Always order this in a consistent way
    for (const [packageSourceName, prefixes] of this.#localPrefixesByPackage) {
      for (const prefix of prefixes) {
        remappings.push({
          context: packageSourceName.rootSourceName,
          prefix,
          target: packageSourceName.rootSourceName + prefix,
        });
      }
    }

    // We sort the remappings acording to the remappings selection rules, plus
    // the targets, which shouldn't be needed.
    remappings
      .sort((a, b) => a.target.localeCompare(b.target))
      .sort((a, b) => a.target.length - b.target.length)
      .sort((a, b) => a.prefix.localeCompare(b.prefix))
      .sort((a, b) => a.prefix.length - b.prefix.length)
      .sort((a, b) => a.context.localeCompare(b.context))
      .sort((a, b) => a.context.length - b.context.length);

    return [...userRemappings, ...remappings];
  }

  // >>>>>>>>>> BEGIN SECTION: Import resolution selection
  //
  // The private methods in this section are in charge of selecting which import
  // resolution technique to use, but they don't create any ResolvedFile.
  //
  // These techniques are:
  //  1. Resolving an import to a project file
  //  2. Resolving an import remapped by the user into an npm package
  //  3. Resolving an import from an npm package to one of its own files with a
  //     relative import
  //  4. Resolving an import from an npm package to one of its own files with a
  //     direct import — This case is different from 3, as without especial care
  //     it could be affected by one of the user remappings.
  //  5. Resolving an import to a different npm package using our own remappings

  /**
   * Resolves an import from a project file.
   *
   * This method applies the user remappings, if necessary, and uses the
   * appropriate resolution technique.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but before applying any remapping.
   */
  async #resolveImportFromProjectFile({
    from,
    importPath,
    directImport,
  }: {
    from: ProjectResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<ResolvedFile> {
    const bestUserRemapping = selectBestRemapping(
      from.sourceName,
      directImport,
      this.#userRemappings,
    );

    if (bestUserRemapping !== undefined) {
      return this.#resolveUserRemappedImportFromProjectFile({
        from,
        importPath,
        directImport,
        remapping: bestUserRemapping,
      });
    }

    if (await this.#isDirectImportLocal(this.#projectRoot, directImport)) {
      return this.#resolveImportToProjectFile({
        from,
        importPath,
        fsPathWithinTheProject: sourceNamePathToFsPath(directImport),
      });
    }

    return this.#resolveImportThroughNpm({
      from,
      importPath,
      directImport,
    });
  }

  /**
   * Resolves an import from a project file that is affected by a user
   * remapping.
   *
   * Note that this method must only be called with the best user remapping
   * applicable to the import, as defined by solc. Otherwise, it's behavior will
   * be misleading.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but before applying any remapping.
   * @param remapping The user remapping that will be applied.
   */
  async #resolveUserRemappedImportFromProjectFile({
    from,
    importPath,
    directImport,
    remapping,
  }: {
    from: ProjectResolvedFile;
    importPath: string;
    directImport: string;
    remapping: ResolvedUserRemapping;
  }): Promise<ResolvedFile> {
    const remappedDirectImport = applyValidRemapping(directImport, remapping);

    // Special case, where a user remapping's target is an npm pacakge
    if (remapping.targetNpmPackage !== undefined) {
      return this.#resolveImportToNpmPackageRemappedByUser({
        from,
        importPath,
        directImport: remappedDirectImport,
        remapping: {
          // This weird syntax is because TS doesn't realize that
          // bestUserRemapping is Required<ResolvedUserRemapping> here
          ...remapping,
          targetNpmPackage: remapping.targetNpmPackage,
        },
      });
    }

    if (
      !(await this.#isDirectImportLocal(
        this.#projectRoot,
        remappedDirectImport,
      ))
    ) {
      throw new HardhatError(
        HardhatError.ERRORS.CORE.SOLIDITY.ILLEGAL_PROJECT_IMPORT_AFTER_REMAPPING,
        {
          importPath,
          from: shortenPath(from.fsPath),
          remapping: remapping.rawFormat,
          remappedDirectImport,
        },
      );
    }

    return this.#resolveImportToProjectFile({
      from,
      importPath,
      fsPathWithinTheProject: sourceNamePathToFsPath(remappedDirectImport),
    });
  }

  /**
   * Resolves an import from an npm file.
   *
   * This method does not apply any remapping that may be present in the npm
   * package.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but without applying any remapping.
   */
  async #resolveImportFromNpmPackageFile({
    from,
    importPath,
    directImport,
  }: {
    from: NpmPackageResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<ResolvedFile> {
    // If we wanted to apply its own remappings, this would be the place.
    // Initially we won't support it.
    if (directImport.startsWith(from.package.rootSourceName)) {
      return this.#resolveRelativeImportFromNpmPackage({
        from,
        importPath,
        directImport,
      });
    }

    // This was already a direct import, and may be to the same package.
    // As we allow this imports in the local project files, we should also allow
    // them on npm packages. If we don't projects won't be easily distributable
    // through npm, even if they don't use remappings.
    if (
      await this.#isDirectImportLocal(from.package.rootFsPath, directImport)
    ) {
      const resolvedFile = await this.#resolveLocalImportFromNpmPackage({
        from,
        importPath,
        directImport,
      });

      let prefixesNeededByPackage = this.#localPrefixesByPackage.get(
        from.package,
      );

      if (prefixesNeededByPackage === undefined) {
        prefixesNeededByPackage = new Set();
        this.#localPrefixesByPackage.set(from.package, prefixesNeededByPackage);
      }

      prefixesNeededByPackage.add(
        this.#getDirectImportLocalDesambiguationPrefix(directImport),
      );

      return resolvedFile;
    }

    return this.#resolveImportThroughNpm({
      from,
      importPath,
      directImport,
    });
  }

  /**
   * This method resolves an import that has to go through the npm resolution
   * process and selects the appropriate technique to resolve it.
   *
   * This method does not apply nor define any remapping, but it populates the
   * `#dependencyMaps` with dependencies that each package uses, so that we can
   * create all the necessary remappings at the end of the resolution process.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but without applying any remapping.
   */
  async #resolveImportThroughNpm({
    from,
    importPath,
    directImport,
  }: {
    from: ResolvedFile;
    importPath: string;
    directImport: string;
  }): Promise<ResolvedFile> {
    const parsedDirectImport = this.#parseNpmDirectImport(directImport);

    if (parsedDirectImport === undefined) {
      throw new HardhatError(
        HardhatError.ERRORS.CORE.SOLIDITY.INVALID_NPM_IMPORT,
        {
          importPath,
          from: shortenPath(from.fsPath),
        },
      );
    }

    const dependency = await this.#resolveNpmPackageForImport({
      from,
      importPath,
      importPackageName: parsedDirectImport.package,
    });

    if (dependency === PROJECT_ROOT_SENTINEL) {
      return this.#resolveImportToProjectFile({
        from,
        importPath,
        // If we import a file through npm and end up in the Hardhat project,
        // we are going to remap the importPackageName to "", so that the path
        // section of the parsed direct import should be the relative path.
        fsPathWithinTheProject: sourceNamePathToFsPath(
          parsedDirectImport.subpath,
        ),
      });
    }

    return this.#resolveImportToNpmPackage({
      from,
      importPath,
      importedPackage: dependency,
      subpath: parsedDirectImport.subpath,
    });
  }

  // >>>>>>>>>> END SECTION: Import resolution selection

  // >>>>>>>>>> BEGIN SECTION: Import resolution techniques
  //
  // The private methods in this section implement the different import
  // import resolution techniques, which have been explained in the previous
  // section.

  /**
   * This method implements the import resolution technique number 1: Importing
   * a file that is within the project. Note that this method applies both to
   * imports from project files as well as imports from npm packages that may
   * have the project as a dependency.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param pathWithinTheProject The path within the project to import, after
   * normalizing relative paths, applying user remappings and/or stripping the
   * npm package name.
   */
  async #resolveImportToProjectFile({
    from,
    importPath,
    fsPathWithinTheProject,
  }: {
    from: ResolvedFile;
    importPath: string;
    fsPathWithinTheProject: string;
  }): Promise<ProjectResolvedFile> {
    const sourceName = fsPathToSourceNamePath(fsPathWithinTheProject);
    const existing = this.#resolvedFileBySourceName.get(sourceName);
    if (existing !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a ProjectResolvedFile */
      return existing as ProjectResolvedFile;
    }

    // This is a project file, so if it was imported from a local file, this
    // is the direct import, without any remapping or necessary consideration.
    // If this was imported from an npm package, we are remapping the package
    // name of the import to "", so that the direct import is also the same as
    // the relative path.
    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativeFsPathToValidate: fsPathWithinTheProject,
      absoluteFsPathToValidateFrom: this.#projectRoot,
    });

    const fsPath = path.join(this.#projectRoot, fsPathWithinTheProject);

    const resolvedFile: ProjectResolvedFile =
      new ProjectResolvedFileImplementation({
        sourceName,
        fsPath,
        content: await this.#readFileContent(fsPath),
      });

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 2: A project
   * file has an import that should be resolved to a file in an npm package due
   * to a user remapping.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * and applying the user remapping.
   * @param remapping The remapping that was applied.
   */
  async #resolveImportToNpmPackageRemappedByUser({
    from,
    importPath,
    directImport,
    remapping,
  }: {
    from: ProjectResolvedFile;
    importPath: string;
    directImport: string;
    remapping: Required<ResolvedUserRemapping>;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = directImport;
    const existing = this.#resolvedFileBySourceName.get(sourceName);
    if (existing !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return existing as NpmPackageResolvedFile;
    }

    const subpath = path.relative(
      remapping.targetNpmPackage.rootSourceName,
      directImport,
    );
    const resolvedSubpath = resolveSubpath(remapping.targetNpmPackage, subpath);

    // We don't add the dependency to `this.#dependencyMaps` because we
    // don't need a new remapping for this package, as it's already
    // remapped by the user.

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativeFsPathToValidate: sourceNamePathToFsPath(resolvedSubpath),
      absoluteFsPathToValidateFrom: remapping.targetNpmPackage.rootFsPath,
      usingPackageExports: remapping.targetNpmPackage.exports !== undefined,
    });

    const fsPath = path.join(
      remapping.targetNpmPackage.rootFsPath,
      resolvedSubpath,
    );

    const resolvedFile: NpmPackageResolvedFile =
      new NpmPackageResolvedFileImplementation({
        sourceName,
        fsPath,
        content: await this.#readFileContent(fsPath),
        package: remapping.targetNpmPackage,
      });

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 3: A file
   * from an npm package is importing another file from the same package with a
   * relative import.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths.
   * It must start with the package's root source name.
   */
  async #resolveRelativeImportFromNpmPackage({
    from,
    importPath,
    directImport,
  }: {
    from: NpmPackageResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = directImport;
    const existing = this.#resolvedFileBySourceName.get(sourceName);
    if (existing !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return existing as NpmPackageResolvedFile;
    }

    const relativePath = sourceNamePathToFsPath(
      path.relative(from.package.rootSourceName, directImport),
    );

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativeFsPathToValidate: relativePath,
      absoluteFsPathToValidateFrom: from.package.rootFsPath,
    });

    const filePath = path.join(from.package.rootFsPath, relativePath);

    const resolvedFile: NpmPackageResolvedFile =
      new NpmPackageResolvedFileImplementation({
        sourceName,
        fsPath: filePath,
        content: await this.#readFileContent(filePath),
        package: from.package,
      });

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 4: A file
   * from an npm package is importing another file from the same package with a
   * direct import.
   *
   * For example, a file `node_modules/foo/File.sol` imports
   * `node_modules/foo/bar/File2.sol` with the direct import `bar/File2.sol`.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths.
   * The direct import must be considered local within the package, according to
   * the rules of the `#isDirectImportLocal` method.
   */
  async #resolveLocalImportFromNpmPackage({
    from,
    importPath,
    directImport,
  }: {
    from: NpmPackageResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = from.package.rootSourceName + directImport;
    const existing = this.#resolvedFileBySourceName.get(sourceName);
    if (existing !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return existing as NpmPackageResolvedFile;
    }

    const relativeFsPath = sourceNamePathToFsPath(directImport);

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativeFsPathToValidate: relativeFsPath,
      absoluteFsPathToValidateFrom: from.package.rootFsPath,
    });

    const fsPath = path.join(from.package.rootFsPath, relativeFsPath);

    const resolvedFile: NpmPackageResolvedFile =
      new NpmPackageResolvedFileImplementation({
        sourceName,
        fsPath,
        content: await this.#readFileContent(fsPath),
        package: from.package,
      });

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 5: A file,
   * within the project or from an npm pacakge, is importing a file from a
   * different npm package.
   *
   * Note: This is not meant to support imports into the Hardhat project.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param importedPackage The NpmPackage that is being imported.
   * @param subpath The path to the file to import, within the
   * package. That means, after parsing the direct import, and stripping the
   * package part, before resolving package exports.
   */
  async #resolveImportToNpmPackage({
    from,
    importPath,
    importedPackage,
    subpath,
  }: {
    from: ResolvedFile;
    importPath: string;
    importedPackage: ResolvedNpmPackage;
    subpath: string;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = importedPackage.rootSourceName + subpath;

    const existing = this.#resolvedFileBySourceName.get(sourceName);
    if (existing !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return existing as NpmPackageResolvedFile;
    }

    // We use the subpath (pre-resolution) to create source names
    const resolvedSubpath = resolveSubpath(importedPackage, subpath);

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativeFsPathToValidate: sourceNamePathToFsPath(resolvedSubpath),
      absoluteFsPathToValidateFrom: importedPackage.rootFsPath,
      usingPackageExports: importedPackage.exports !== undefined,
    });

    const fsPath = path.join(importedPackage.rootFsPath, resolvedSubpath);

    const resolvedFile: NpmPackageResolvedFile =
      new NpmPackageResolvedFileImplementation({
        sourceName,
        fsPath,
        content: await this.#readFileContent(fsPath),
        package: importedPackage,
      });

    this.#resolvedFileBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  // >>>>>>>>>> END SECTION: Import resolution techniques

  /**
   * Resolves an npm package as a dependency of another one.
   *
   * @param from The package to resolve the dependency from.
   * @param packageName The name of the package that should be resolved as a
   * dependency.
   * @returns A ResolvedNpmPackage or PROJECT_ROOT_SENTINEL.
   */
  async #resolveNpmPackage({
    from,
    packageName,
  }: {
    from: ResolvedNpmPackage | typeof PROJECT_ROOT_SENTINEL;
    packageName: string;
  }): Promise<ResolvedNpmPackage | typeof PROJECT_ROOT_SENTINEL> {
    let dependenciesMap = this.#dependencyMaps.get(from);
    if (dependenciesMap === undefined) {
      dependenciesMap = new Map();
      this.#dependencyMaps.set(from, dependenciesMap);
    }

    const dependency = dependenciesMap.get(packageName);
    if (dependency !== undefined) {
      return dependency;
    }

    const baseResolutionDirectory =
      from === PROJECT_ROOT_SENTINEL ? this.#projectRoot : from.rootFsPath;

    // TODO: This is a quick fix for Hardhat's own package.json, for the alpha
    // release. We should find a better way to handle this.
    // We also need to figure out a way to test this inside the monorepo,
    // without the package `hardhat` in the top-level `node_modules` folder
    // interfering with the resolution.

    const packageJsonPath =
      packageName === "hardhat"
        ? await findClosestPackageJson(import.meta.dirname)
        : await findDependencyPackageJson(baseResolutionDirectory, packageName);

    if (packageJsonPath === undefined) {
      throw new HardhatError(
        HardhatError.ERRORS.CORE.SOLIDITY.NPM_DEPEDNDENCY_NOT_INSTALLED,
        {
          from:
            from === PROJECT_ROOT_SENTINEL
              ? "your project"
              : `"${shortenPath(from.rootFsPath)}"`,
          packageName,
        },
      );
    }

    if (isPackageJsonFromProject(packageJsonPath, this.#projectRoot)) {
      dependenciesMap.set(packageName, PROJECT_ROOT_SENTINEL);
      return PROJECT_ROOT_SENTINEL;
    }

    const packageJson = await readJsonFile<{
      name: string;
      version: string;
      exports?: resolve.Exports;
    }>(packageJsonPath);

    const name = packageJson.name;
    const version = isPackageJsonFromMonorepo(
      packageJsonPath,
      this.#projectRoot,
    )
      ? "local"
      : packageJson.version;

    const npmPackage: ResolvedNpmPackage = {
      name,
      version,
      exports: packageJson.exports,
      rootFsPath: path.dirname(packageJsonPath),
      rootSourceName: npmPackageToRootSourceName(name, version),
    };

    dependenciesMap.set(packageName, npmPackage);
    return npmPackage;
  }

  /**
   * Resolves the npm package imported by the importPath in the from file.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param importPackageName The name of the package to import, as present in
   * the importPath, and not necessarily the name of the package in the
   * package.json.
   * @returns A ResolvedNpmPackage or PROJECT_ROOT_SENTINEL.
   */
  async #resolveNpmPackageForImport({
    from,
    importPath,
    importPackageName,
  }: {
    from: ResolvedFile;
    importPath: string;
    importPackageName: string;
  }): Promise<ResolvedNpmPackage | typeof PROJECT_ROOT_SENTINEL> {
    try {
      return await this.#resolveNpmPackage({
        from:
          from.type === ResolvedFileType.PROJECT_FILE
            ? PROJECT_ROOT_SENTINEL
            : from.package,
        packageName: importPackageName,
      });
    } catch (error) {
      ensureError(error);

      if (
        HardhatError.isHardhatError(
          error,
          HardhatError.ERRORS.CORE.SOLIDITY.NPM_DEPEDNDENCY_NOT_INSTALLED,
        )
      ) {
        throw new HardhatError(
          HardhatError.ERRORS.CORE.SOLIDITY.IMPORTED_NPM_DEPENDENCY_NOT_INSTALLED,
          {
            from: shortenPath(from.fsPath),
            importPath,
          },
          error,
        );
      }

      throw error;
    }
  }

  /**
   * This method returns true if a direct import should be considered an import
   * to a local file when evaluated in the context of the Hardhat project.
   */
  async #isDirectImportLocal(
    projectOrPackageRootFsPath: string,
    directImport: string,
  ): Promise<boolean> {
    if (directImport === "hardhat/console.sol") {
      return false;
    }

    const slash = directImport.indexOf("/");

    // If it's a file in the root directory
    if (slash === -1) {
      return true;
    }

    const firstDirectory = directImport.substring(0, slash);

    // TODO: Cache this?
    return exists(path.join(projectOrPackageRootFsPath, firstDirectory));
  }

  /**
   * Returns the prefix used to desambiguate a directImport by
   * #isDirectImportLocal to determine if its local.
   *
   * For example, the prefix for `foo/bar/File.sol`, this returns `foo/`.
   *
   * NOTE: This method does not support `hardhat/console.sol`, as that's a
   * special case, which is never considered local.
   */
  #getDirectImportLocalDesambiguationPrefix(directImport: string): string {
    const slash = directImport.indexOf("/");

    // If it's a file in the root directory
    if (slash === -1) {
      return directImport;
    }

    const firstDirectory = directImport.substring(0, slash + 1);

    return firstDirectory;
  }

  /**
   * This is an utility method that validates the existance and casing of an
   * imported file as part of the different resolution techniques.
   *
   * `from` and `importPath` are used to provide a user-friendly error message,
   * but the actual validation is done using `relativePathToValidate` and
   * `absolutePathToValidateFrom`.
   *
   * @param from The file with the import.
   * @param importPath The import path, as written in the source code.
   * @param relativePathToValidate The relative path to validate its existance.
   * @param absolutePathToValidateFrom The absolute path from in which the
   * relative path is.
   * @param usingPackageExports Whether the import is using package exports,
   * which controls which kind of error is thrown.
   */
  async #validateExistanceAndCasingOfImport({
    from,
    importPath,
    relativeFsPathToValidate,
    absoluteFsPathToValidateFrom,
    usingPackageExports,
  }: {
    from: ResolvedFile;
    importPath: string;
    relativeFsPathToValidate: string;
    absoluteFsPathToValidateFrom: string;
    usingPackageExports?: boolean;
  }) {
    let trueCaseFsPath: string;
    try {
      trueCaseFsPath = await getFileTrueCase(
        absoluteFsPathToValidateFrom,
        relativeFsPathToValidate,
      );
    } catch (error) {
      ensureError(error, FileNotFoundError);

      throw new HardhatError(
        HardhatError.ERRORS.CORE.SOLIDITY.IMPORTED_FILE_DOESNT_EXIST,
        { importPath, from: shortenPath(from.fsPath) },
        error,
      );
    }

    if (relativeFsPathToValidate !== trueCaseFsPath) {
      // If we are using package exports, we need to throw a special error,
      // as we can't compute the correct casing.
      if (usingPackageExports === true) {
        throw new HardhatError(
          HardhatError.ERRORS.CORE.SOLIDITY.IMPORTED_PACKAGE_EXPORTS_FILE_WITH_INCORRECT_CASING,
          {
            importPath,
            from: shortenPath(from.fsPath),
          },
        );
      }

      throw new HardhatError(
        HardhatError.ERRORS.CORE.SOLIDITY.IMPORTED_FILE_WITH_INCORRECT_CASING,
        {
          importPath,
          from: shortenPath(from.fsPath),
          correctCasing: fsPathToSourceNamePath(trueCaseFsPath),
        },
      );
    }
  }

  /**
   * Parses a direct import as if it were an npm import, returning `undefined`
   * if the format is invalid.
   *
   * Note: The returned subpath is not an fs path, and always use path.posix.sep
   */
  #parseNpmDirectImport(directImport: string):
    | {
        package: string;
        subpath: string;
      }
    | undefined {
    // NOTE: We assume usage of path.posix.sep in the direct import
    const directImportPattern =
      /^(?<package>(?:@[a-z0-9-~._]+\/)?[a-z0-9-~][a-z0-9-~._]*)\/(?<path>.*)$/;

    const match = directImportPattern.exec(directImport);

    if (match === null) {
      return undefined;
    }

    assertHardhatInvariant(
      match.groups !== undefined,
      "Groups should be defined because they are part of the pattern",
    );

    return { package: match.groups.package, subpath: match.groups.path };
  }

  /**
   * Reads and analyzes the file at the given absolute path.
   */
  async #readFileContent(absolutePath: string): Promise<FileContent> {
    const text = await this.#readFile(absolutePath);
    const { imports, versionPragmas } = analyze(text);

    return {
      text,
      importPaths: imports,
      versionPragmas,
    };
  }
}

async function validateAndResolveUserRemapping(
  projectRoot: string,
  remappingString: string,
): Promise<ResolvedUserRemapping> {
  const remapping = parseRemappingString(remappingString);

  if (remapping === undefined) {
    throw new HardhatError(
      HardhatError.ERRORS.CORE.SOLIDITY.REMAPPING_WITH_INVALID_SYNTAX,
      {
        remapping: remappingString,
      },
    );
  }

  if (remapping.context.startsWith("npm/")) {
    throw new HardhatError(
      HardhatError.ERRORS.CORE.SOLIDITY.USER_REMAPPING_WITH_NPM_CONTEXT,
      { remapping: remappingString },
    );
  }

  if (!remapping.target.startsWith("npm/")) {
    return { ...remapping, rawFormat: remappingString };
  }

  const parsed = parseNpmRemappingTarget(remapping.target);

  if (parsed === undefined) {
    throw new HardhatError(
      HardhatError.ERRORS.CORE.SOLIDITY.REMAPPING_WITH_INVALID_SYNTAX,
      { remapping: remappingString },
    );
  }

  const { packageName, packageVersion } = parsed;

  const dependencyPackageJsonPath = await findDependencyPackageJson(
    projectRoot,
    packageName,
  );

  if (dependencyPackageJsonPath === undefined) {
    throw new HardhatError(
      HardhatError.ERRORS.CORE.SOLIDITY.REMAPPING_TO_UNINSTALLED_PACKAGE,
      { remapping: remappingString, package: packageName },
    );
  }

  if (isPackageJsonFromMonorepo(dependencyPackageJsonPath, projectRoot)) {
    if (packageVersion !== "local") {
      throw new HardhatError(
        HardhatError.ERRORS.CORE.SOLIDITY.REMAPPING_NPM_PACKAGE_AS_MONOREPO,
        {
          remapping: remappingString,
          pacakge: packageName,
          version: packageVersion,
        },
      );
    }
  }

  if (isPackageJsonFromProject(dependencyPackageJsonPath, projectRoot)) {
    throw new HardhatError(
      HardhatError.ERRORS.CORE.SOLIDITY.REMAPPING_HARDHAT_PROJECT_AS_MONOREPO_PACKAGE,
      { remapping: remappingString, package: packageName },
    );
  }

  const npmPackage: ResolvedNpmPackage = {
    name: packageName,
    version: packageVersion,
    rootFsPath: path.dirname(dependencyPackageJsonPath),
    rootSourceName: npmPackageToRootSourceName(packageName, packageVersion),
  };

  if (isPackageJsonFromNpmPackage(dependencyPackageJsonPath)) {
    const dependencyPackageJson = await readJsonFile<{
      version: string;
      exports: resolve.Exports;
    }>(dependencyPackageJsonPath);

    if (dependencyPackageJson.version !== packageVersion) {
      throw new HardhatError(
        HardhatError.ERRORS.CORE.SOLIDITY.REMAPPING_INCORRECT_VERSION,
        {
          remapping: remappingString,
          package: packageName,
          expectedVersion: packageVersion,
          actualVersion: dependencyPackageJson.version,
        },
      );
    }

    npmPackage.exports = dependencyPackageJson.exports;
  }

  return {
    ...remapping,
    targetNpmPackage: npmPackage,
    rawFormat: remappingString,
  };
}

function parseNpmRemappingTarget(remappingTarget: string):
  | {
      packageName: string;
      packageVersion: string;
    }
  | undefined {
  const npmTargetPattern =
    /^npm\/(?<package>(?:@[a-z0-9-~._]+\/)?[a-z0-9-~][a-z0-9-~._]*)@(?<version>local|\d+\.\d+\.\d+)\//;

  const match = npmTargetPattern.exec(remappingTarget);

  if (match === null) {
    return undefined;
  }

  assertHardhatInvariant(
    match.groups !== undefined,
    "Groups should be defined because they are part of the pattern",
  );

  return {
    packageName: match.groups.package,
    packageVersion: match.groups.version,
  };
}

function npmPackageToRootSourceName(name: string, version: string): string {
  return `npm/${name}@${version}/`;
}

function isPackageJsonFromMonorepo(
  packageJsonFsPath: string,
  projectRoot: string,
): boolean {
  return (
    !packageJsonFsPath.includes("node_modules") &&
    !packageJsonFsPath.startsWith(projectRoot)
  );
}

function isPackageJsonFromProject(
  packageJsonFsPath: string,
  projectRoot: string,
): boolean {
  return (
    !packageJsonFsPath.includes("node_modules") &&
    packageJsonFsPath.startsWith(projectRoot)
  );
}

function isPackageJsonFromNpmPackage(packageJsonFsPath: string): boolean {
  return packageJsonFsPath.includes("node_modules");
}

/**
 * Transforms an fs path into a sourceName or import path, by normalizing their
 * path separators to /.
 *
 * Note that source
 *
 * Note: This function is exported for testing purposes, but it's not meant to
 * be used outside of the resolver.
 */
export function fsPathToSourceNamePath(fsPath: string): string {
  if (path.sep === "/") {
    return fsPath;
  }

  return fsPath.replace(/\\/g, "/");
}

/**
 * Transforms a sourceName or import path into an fs path, by normalizing their
 * path separators to /.
 *
 * Note: This function is exported for testing purposes, but it's not meant to
 * be used outside of the resolver.
 */
export function sourceNamePathToFsPath(sourceNamePath: string): string {
  if (path.sep === "/") {
    return sourceNamePath;
  }

  return sourceNamePath.replace(/\//g, "\\");
}

/**
 * The equivalent of path.join but for sourceName or import paths, not fs paths.
 */
function sourceNamePathJoin(...parts: string[]): string {
  return fsPathToSourceNamePath(path.join(...parts));
}

/**
 * Resolves a subpath for a given package, when it uses package#exports
 * @param npmPackage
 * @param subpath
 * @returns
 */
function resolveSubpath(
  npmPackage: ResolvedNpmPackage,
  subpath: string,
): string {
  if (npmPackage.exports === undefined) {
    return subpath;
  }
  try {
    // As we are resolving Solidity files, the conditions don't really apply,
    // and Solidity package authors don't use them either.
    //
    // We use `resolve.exports` with the appropiate options so that it only
    // takes the `"default"` condition into account.
    const resolveOutput = resolve.exports(npmPackage, subpath, {
      browser: false,
      conditions: [],
      require: false,
      unsafe: true,
    });

    assertHardhatInvariant(
      resolveOutput !== undefined,
      "resolve.exports should always return a result when package.exports exist",
    );

    const resolvedSubpath = resolveOutput[0].slice(2); // skip the leading './'

    return resolvedSubpath.replace(/\/|\\/g, path.sep); // use fs path separator
  } catch (error) {
    ensureError(error, Error);

    throw new HardhatError(
      HardhatError.ERRORS.CORE.SOLIDITY.RESOLVE_NOT_EXPORTED_NPM_FILE,
      { module: `${npmPackage.name}/${subpath}` },
      error,
    );
  }
}
